type ConstructorProps<
  Section extends HTMLElement,
  NavItem extends HTMLElement,
> = {
  /** List of selectors */
  selectors: {
    /** Selectors for sections */
    sections: string;
    /** Selectors for nav items */
    navItems: string;
  };
  /** List of callbacks */
  callbacks?: {
    /** Callback for observer */
    observer?: (target: Section, map: Map<string, NavItem>) => void;
    /** Callback to generate Map ids */
    mapIds?: (el: NavItem) => string;
  };
  /** List of options */
  options?: {
    /** Options for IntersectionObserver */
    io?: IntersectionObserverInit;
  };
};

export class ScrollObserver<
  Section extends HTMLElement,
  NavItem extends HTMLElement,
> {
  #observer: IntersectionObserver;

  #sections: NodeListOf<Section>;
  #navItems: NodeListOf<NavItem>;

  #navItemsMap: Map<string, NavItem>;

  #cbObserver: (target: Section, map: Map<string, NavItem>) => void;
  #cbMapId: (el: NavItem) => string;

  #optionsIO: IntersectionObserverInit = {};

  constructor({
    selectors,
    callbacks,
    options,
  }: ConstructorProps<Section, NavItem>) {
    this.#sections = document.querySelectorAll<Section>(selectors.sections);
    this.#navItems = document.querySelectorAll<NavItem>(selectors.navItems);

    this.#cbObserver = callbacks?.observer ?? (() => {});
    this.#cbMapId = callbacks?.mapIds ?? ((el) => el.id);

    this.#navItemsMap = this.createMap(this.#navItems, this.#cbMapId);

    this.#optionsIO = options?.io ?? {};

    this.#observer = this.#createObserver();
    this.#observe();
  }

  /**
   * Creates a map where the keys are generated by applying the callback function to each element in the list.
   *
   * @param {NodeListOf<T>} list - The list of elements to create the map from.
   * @param {(el: T) => string} cb - The callback function that generates the keys for the map.
   * @return {Map<string, T>} The map with keys generated by the callback function and corresponding elements from the list.
   */
  createMap<T extends HTMLElement>(
    list: NodeListOf<T>,
    cb: (el: T) => string,
  ): Map<string, T> {
    const map = new Map<string, T>();
    for (const el of list) {
      map.set(cb(el), el);
    }
    return map;
  }

  /**
   * Creates and returns an IntersectionObserver instance that observes the intersection of the target elements with the viewport.
   * When an observed element intersects with the viewport, the provided callback function is executed with the target element and the navigation items map as arguments.
   *
   * @return {IntersectionObserver} The created IntersectionObserver instance.
   */
  #createObserver(): IntersectionObserver {
    return new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          this.#cbObserver(entry.target as Section, this.#navItemsMap);
        }
      });
    }, this.#optionsIO);
  }

  /**
   * Observes each section
   */
  #observe(): void {
    for (const section of this.#sections) {
      this.#observer.observe(section);
    }
  }
}
